<!DOCTYPE html>
<html>
<!-- TODO: create more in page links if needed such as a refrence in one section to another -->
<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Cachestore : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <link rel="stylesheet" href="./stylesheets/flama.css">
    <link rel="shortcut icon" href="./images/favicon.png">

    
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
<script language="javascript" src="./javascripts/main.js"></script>
    
    <style type="text/css">
        OL {
            counter-reset: item;
        }
        
        LI {
            display: block
        }
        
        LI:before {
            content: counters(item, ".") ". ";
            counter-increment: item
        }
        
        LI.default {
            display: list-item
        }
        
        LI.default:before {
            content: "";
        }
    </style>
    <title>CacheStore For Dummies</title>
</head>

<body>
<a href="#" class="back-to-top">Back to Top</a>
    <!-- HEADER -->
    <div id="header_wrap" class="outer">

        <header class="inner">
            <a id="forkme_banner" href="https://github.com/viant/CacheStore">View on GitHub</a>
            <a id="viant_banner" href="http://viant.github.io/">Viant Engineering</a>


            <h1 id="project_title">CacheStore Usage Guide</h1>
            <h2 id="project_tagline">A Practical Guide and Code Usage</h2>

            <section id="downloads">
                <a class="folder_link" href="./Downloads.html">
                    <br style="line-height:25px;">Downloads</a>
                <a class="folder_link" href="./Changelog.html">
                    <br style="line-height:25px;">Changelog</a>
                <a class="folder_link" href="./CacheStore-Shell.html">
                    <br>Groovy
                    <br>Shell</a>
                <a class="folder_link" href="./Object-Query.html">
                    <br>Object
                    <br>Query</a>
                <a class="folder_selected" href="./CacheStore-For-Dummies.html">
                    <br>Usage
                    <br>Guide</a>
                <a class="folder_link" href="./index.html">
                    <br style="line-height:25px;">Home</a>
                <!--
                <a class="zip_download_link" href="https://github.com/viant/CacheStore/zipball/master">Download this project as a .zip file</a>
                <a class="tar_download_link" href="https://github.com/viant/CacheStore/tarball/master">Download this project as a tar.gz file</a>
                -->
            </section>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
        <section id="main_content" class="inner">

            <h2>
          <a id="table-of-contents" class="anchor" href="#table-of-contents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Table of Contents</h2>


            <ol>
                <li>
                    <a href="#introduction">Introduction</a>
                </li>
                <li>
                    <a href="#server">Server - Remotes, Clusters, and Stores</a>
                    <ol>
                        <li>
                            <a href="#start-remote">Start Remote</a>
                        </li>
                        <li>
                            <a href="#start-cluster">Start Cluster</a>
                        </li>
                        <li>
                            <a href="#triggers">Triggers</a>
                        </li>
                        <li>
                            <a href="#stored-procedures">Stored Procedures</a>
                        </li>
                        <li>
                            <a href="#queries">Queries</a>
                        </li>
                        <li>
                            <a href="#mapreduce">Map Reduce</a>
                        </li>
                    </ol>
                </li>
                <li>
                    <a href="#client">Client - Connection and Functions</a>
                    <ol>
                        <li>
                            <a href="#remote-client">Creating a Remote Client</a>
                        </li>
                        <li>
                            <a href="#scan-client">Creating a Scan Client</a>
                        </li>
                        <li>
                            <a href="#cluster-client">Creating a Cluster Client</a>
                        </li>
                        <li>
                            <a href="#client-functions">Client Functions</a>
                            <ol>
                                <li>
                                    <a href="#get-put">Get/Put</a>
                                </li>
                                <li>
                                    <a href="#removed">Remove</a>
                                </li>
                                <li>
                                    <a href="#bulk-operations">Bulk Operations</a>
                                </li>
                                <li>
                                    <a href="#object-query">Object Query</a>
                                    <ol>
                                        <li>
                                            <a href="#object-file">Object File</a>
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    <a href="#scan">Scan</a>
                                </li>
                                <li>
                                    <a href="#cursor">Cursor</a>
                                </li>
                                <li>
                                    <a href="#stored-procedures-2">Stored Procedures</a>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <a href="#key-sequencing">Key Sequencing</a>
                        </li>
                        <li>
                            <a href="#serialization">Serialization</a>
                            <ol>
                                <li>
                                    <a href="#hessian-serialization">Hessian Serialization</a>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <a href="#mapreduce2">Map Reduce</a>
                        </li>
                    </ol>
                </li>
                <li>
                    <a href="#config">Store and Cluster Config Files</a>
                    <ol>
                        <li>
                            <a href="#store-config">Store Config</a>
                            <ol>
                                <li>
                                    <a href="#stores-xml">The stores.xml File</a>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <a href="#cluster-config">Cluster Config</a>
                            <ol>
                                <li>
                                    <a href="#clusters-xml">The clusters.xml File</a>
                                </li>
                                <li>
                                    <a href="#stores-xml-2">The stores.xml File</a>
                                </li>
                                <li>
                                    <a href="#node-properties">The node.properties File</a>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </li>
                <li>
                    <a href="#jmx-monitoring">JMX Monitoring</a>
                </li>
                <li>
                    <a href="#maven">Maven</a>
                    <ol>
                        <li><a href="#maven-dependencies">Maven Depdendencies</a></li>
                    </ol>
                </li>
            </ol>

            <h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1. Introduction</h2>
            <p>
                CacheStore contains a robust set of features implemented in Java that can be utilized to quickly access, manipulate, and modify billions of record sets contained in "stores". CacheStore will read mainly from XML config files to determine how to configure, read, and write store data.
            </p>
            <p>
                This manual will take a look into CacheStore's Java API, XML config files, and general usage. Take note that the Java API can be called either through Java applications or through the <a href=./CacheStore-Shell.html>CacheStore Groovy Shell</a>
            </p>
            <p>
                If you have questions about Object Query syntax, take a look at the <a href=./Object-Query.html> Object Query Guide</a> for reference.
            </p>
            <p>
                Also, in our examples, we will assume a few things:
            </p>
            <ul>
                <li class="default">
                    If a variable is not shown as declared, it is assumed that it has already been declared earlier
                </li>
                <li class="default">
                    If imports are not shown, it is assumed they have already been imported
                </li>
                <li class="default">
                    HOST_CONNECT_URL refers to a host connection URL string. Ex. "localhost:7100"
                </li>
                <li class="default">
                    STORENAME refers to the store being accessed by the client.
                </li>
            </ul>

            <h2>
<a id="server" class="anchor" href="#server" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2. Server - Remotes, Clusters, and Stores</h2>
            <p>
                CacheStore can be deployed in three ways: locally, remotely, and on a cluster. The data within CacheStore is written and saved into what we call "stores". CacheStore servers can be started from either the provided startup scripts, custom startup scripts, or through JVM.
            </p>
            <p>
                When deciding whether to deploy CacheStore as a remote or cluster server, keep in mind the size of your data. The larger data size you have, the more likely you would want to use a cluster deployment over remote deployment.
            </p>
            <h3>
<a id="start-remote" class="anchor" href="#start-remote" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.1. Start Remote</h3>
            <p>
                To start a Remote Store, make a call to RemoteScan4ReplicaServer.java's main method: <code>
                RemoteScan4ReplicaServer.main(args)
            </code>
            </p>
            <p>
                Take note that the argument opts are <code>{"‐configPath", "‐start" }</code> and are defaulted to
                <code>{"./config", "true"}</code>.
            </p>
            <p>
                In addition, you must set the CLASSPATH and Java Memory settings. Because of this, it is HIGHLY recommended to start a server through the startup scripts provided in the Remote Deployment version of CacheStore, found <a href="https://github.com/viant/CacheStore-deploy">Here</a>.
            </p>
            <h3>
<a id="start-cluster" class="anchor" href="#start-cluster" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.2. Start Cluster</h3>
            <p>
                To start a Cluster, make a call to ClusterServer.java's main method:
                <code>
                ClusterServer.main(args)
                </code>
            </p>
            <p>
                Take note that the argument opts are <code>{"‐host","‐configPath","‐dataPath", "‐port", "replicaPort", "‐start", "‐freq"}</code> and are defaulted to <code>{"","",".", "0", "0", "true", "0"}</code>.

            </p>
            <p>
                In addition, you must set the CLASSPATH and Java Memory settings. Because of this, it is HIGHLY recommended to start a server through the startup scripts provided in the Cluster Deployment version of CacheStore, found <a href="https://github.com/viant/CacheStore-deploy-cluster">Here</a>.
            </p>
            <p>
                Each node in the cluster must individually start CacheStore and have the correct config files set up accordingly. Please refer to the Cluster Config Section below and to the Cluster User Guide for more information regarding node setup.
            </p>

            <h3>
<a id="triggers" class="anchor" href="#triggers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.3. Triggers</h3>
            <p>Get, Put and Delete Triggers are implemented on CacheStore servers. Get Triggers occur when doing a "get" operations, Put Triggers occur when doing a "put" operation, and Delete Triggers occur when doing a "remove" operation. Get and Put Triggers have a before operation and after operation function while Delete Triggers only have a before operation.
            </p>
            <p>Triggers are implemented through interfaces GetTrigger.java and PutTrigger.java and their functions must be overridden.</p>
            <p>Get Trigger:</p>
            <pre><code>public class GetTrigger implements com.sm.store.GetTrigger {
    @Override
    public boolean beforeGet(Key key, CacheStore store) {
        System.out.println("Before get");
        return false;
        }
    @Override
        public Value afterGet(Key key, Value value, CacheStore store) {
        System.out.println("After get");
        return value;
    }
}</code></pre>
            <p>
                Put Trigger:
            </p>
            <pre><code>public class PutTrigger implements com.sm.store.PutTrigger {
    @Override
    public boolean beforePut(Key key, Value value, CacheStore store) {
        System.out.println("Before put");
        return false;
    }
    @Override
    public Value afterPut(Key key, Value value, CacheStore store) {
        System.out.println("After put");
        return value;
    }
}</code></pre>
            <p>
                Delete Trigger:
            </p>
            <pre><code>public class DeleteTrigger implements com.sm.store.DeleteTrigger {
    @Override
    public void beforeDelete(Key key, CacheStore store) {
        System.out.println("Before Delete");
    }
}</code></pre>
            <p>
                Once a trigger is created, it must be linked on startup (such as by placing it into lib or dist folder). Also, since triggers are store-specific, each store that implements a trigger must define it in its stores.xml file.
            </p>
            <p>
                XML tags in stores.xml:
            </p>
            <pre><code>&lt;getTrigger&gt;com.mycompany.app.GetTrigger&lt;/getTrigger&gt;
&lt;putTrigger&gt;com.mycompany.app.PutTrigger&lt;/putTrigger&gt;
&lt;deleteTrigger&gt;com.mycompany.app.DeleteTrigger&lt;/deleteTrigger&gt;</code></pre>

            <h3>
<a id="stored-procedures" class="anchor" href="#stored-procedures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.4. Stored Procedures</h3>
            <p>Stored procedures are subroutines stored on servers that can be called by clients. For more information regarding stored procedures in CacheStore, refer to the <a href="#stored-procedures-2">Stored Procedures</a> section under the Client section below.</p>
            <h3>
<a id="queries" class="anchor" href="#quesries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.5. Queries</h3>
            <p>Queries are filtered searches that, like stored procedures, are initiated on the client side, but handled on the servers. More information can be found in the Object Query section under the Client section below.</p>
            <h3>
<a id="mapreduce" class="anchor" href="#mapreduce" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.6. Map Reduce</h3>
            <p>CacheStore servers all have the ability to use the built in Map Reducer. The <a href="https://en.wikipedia.org/wiki/MapReduce">Map Reduce</a> is implemented through multithreading on each server. A single server will distribute work among the specified thread count. A cluster of servers will already split work among the different servers in the cluster, with each server in the cluster splitting its own work among its different threads specified by the user. After the Map has finished, the Reduce is executed and the results can be combined.</p>
            <p>
            The execution of the server-side Map Reduce is similar to how <a href="#stored-procedures-2">Stored Procedures</a> are created and executed. Please refer to the <a href="#mapreduce2">Client-side Map Reduce</a> section for more information.
            </p>
            <p>
                In order to run Map Reduce, you must have the Map Reduce procedure and model object on both the client and the server. In addition, you must have a scan.xml in your config path that contains the stores that defines stores accessible to Map Reduce. The contents of this scan.xml file is defined in the same way that <a href=#stores-xml>stores.xml</a> is and should be a subset of stores.xml. Map Reduce WILL NOT WORK without scan.xml defined.
            </p>


            <h2>
<a id="client" class="anchor" href="#client" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3. Client - Connection and Functions</h2>
            <p>
                Before anything can be done on the servers, there must be a client to connect in order to interact with the servers.</p>
            <h3>
<a id="remote-client" class="anchor" href="#remote-client" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.1. Creating a Remote Client</h3>
            <p>The remote client is the basic client used to connect to a remote store. It is a lightweight client that has a simple implementation that can be easily customized and adjusted for other programming languages.</p>
            <pre><code>RemoteClientImpl client = new NTRemoteClientImpl(HOST_CONNECT_URL, null, STORENAME);
</code></pre>
            <h3>
<a id="scan-client" class="anchor" href="#scan-client" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2. Creating a Scan Client</h3>
            <p>The scan client is a superset of the remote client as it extends the remote client and is dependent on more libraries, making it more difficult to customize and adjust for other languages, but making it have more features and be more powerful than the basic remote client.

            </p>
            <pre><code>ScanClientImpl client = new GZScanClientImpl(HOST_CONNECT_URL, null, STORENAME);
</code></pre>
            <h3>
<a id="cluster-client" class="anchor" href="#cluster-client" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.3. Creating a Cluster Client</h3>
            <p>The cluster client connects to a store within a cluster. Because clusters work together and concurrently, it doesn't matter which node within the cluster you connect to as they will access the same store.
            </p>
            <pre><code>ccf = ClusterClientFactory.connect(HOST_CONNECT_URL, STORENAME);
client = ccf.getDefaultStore();</code></pre>
            <h3>
<a id="client-functions" class="anchor" href="#client-functions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4. Client Functions</h3>
            <p>Each type of CacheStore remote and cluster clients will generally have the same basic functions, such as "get" and "put", but some of the more advanced functions are only available or specifically tailored in certain types of clients. Because scan clients are a superset of Remote clients, they will have all the functions of remote clients and more.

            </p>
            <h4>
<a id="get-put" class="anchor" href="#get-put" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.1. Get/Put</h4>
            <p>
                The most basic of operations in a key-value storage system are the get and put commands. CacheStore is capable of storing object version and node information alongside object data information.</p>
            <p>A simple get/put example:</p>
            <pre><code>Key&lt;Integer&gt; k = Key.createKey(1);
ByteArray FooBar = new ByteArray("FooBar".getBytes());
client.put(k, FooBar);
Value&lt;ByteArray&gt; value = client.get(k);</code></pre>
            <p>The Key and ByteArray are placed into the store by the client with "put" and is then retrieved as a Value with "get".

            </p>
            <h4>
<a id="remove" class="anchor" href="#remove" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.2. Remove</h4>
            <p>Remove is used to delete an existing key-value pair by key:</p>
            <pre><code>client.remove(k);</code></pre>
            <h4>
<a id="bulk-operations" class="anchor" href="#bulk-operations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.3. Bulk Operations</h4>
            <p>CacheStore supports a bulk (also known as multiOperation) system that allows users to easily and quickly get/put/remove keys and values. Keep in mind that multiOperations take in a query String as one of the parameters, but this parameter can also be null. Query String syntax can be found at: <a href=./Object-Query.html> Object Query Guide</a>.</p>
            <p>The following is an example of multiGets, multiPuts, and multiRemoves:</p>
            <pre><code>List&lt;KeyValue&gt; mGet = client.multiGets(keyList);
client.multiRemove(keyList);
client.multiPuts(mGet);</code></pre>
            <h4>
<a id="object-query" class="anchor" href="#object-query" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.4. Object Query</h4>
            <p>Although queries are handled by the CacheStore server, they are initiated by CacheStore clients. CacheStore supports full Object Queries minus aggregation and joins. Please refer to the <a href=./Object-Query.html> Object Query Guide</a> for an object query overview and query statement syntax.</p>
            <p>There are two main query functions, query and query4Json. Query returns a List of key value pairs while query4Json returns a List of Strings or a String that can be converted into JSON objects.</p>
            <p>Remote/Scan:</p>
            <pre><code>List&lt;KeyValue&gt; queryResults = client.query("select name, age, height from Person where key# = 100");
String query4JResults = client.query4Json("select name, age from Student");</code></pre>
            <p>Cluster:</p>
            <pre><code>List&lt;KeyValue&gt; queryResults = client.query("select grade from Class where key# = 100");
List&lt;String&gt; query4JResults = client.query4Json("select name, age, salary from Employee");</code></pre>
            <h5>
<a id="object-file" class="anchor" href="#object-file" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.4.1. Object File</h5>
            <p>Since the Object Query runs queries on objects, then of course we need some sort of object file. In Java, our object files will be in the form of Classes.</p>
            <p>Here is a simple implementation of the Student Class referred in the examples above:</p>
            <pre><code>import java.io.Serializable;

public class Student implements Serializable {
    String name;
    int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}</code></pre>
            <p>CacheStore is not limited to this Student Class. Other implementations can also be used as well. More information can be found in the <a href=./Object-Query.html> Object Query Guide</a>.</p>
            <h4>
<a id="scan" class="anchor" href="#scan" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.5. Scan</h4>
            <p>A range scan is a mechanism to search through a range of keys by reading index entries sequentially. These types of scans can be done in CacheStore and can be optionally filtered using a query statement. Scans in CacheStore can only be done on sorted stores.</p>
            <pre><code>List&lt;KeyValue&gt; scanResult1 = client.scan(key1, key2, null);
List&lt;KeyValue&gt; scanResult2 = client.scan(key3, key4, queryString);</code></pre>
            <h4>
<a id="cursor" class="anchor" href="#cursor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.6. Cursor</h4>
            <p>A cursor is a control structure that allows traversal over records. Cursors in CacheStore are implemented for range scans, key iterators, and key-value pairs.</p>
            <p>A simple use of scan cursors:</p>
            <pre><code>CursorPara keyCursor = client.openKeyCursor((short) 1000);
System.out.println("KeyCursor: "+keyCursor.getKeyValueList());
keyCursor = client.nextCursor(keyCursor);
System.out.println("KeyCursor next: "+keyCursor.getKeyValueList());
client.closeCursor(keyCursor);

CursorPara keyValueCursor = client.openKeyValueCursor((short) 900);
System.out.println("KeyValueCursor: "+keyValueCursor.getKeyValueList());
keyValueCursor = client.nextCursor(keyValueCursor);
System.out.println("KeyValueCursor next: "+keyValueCursor.getKeyValueList());
client.closeCursor(keyValueCursor);

CursorPara scanCursor = client.openScanCursor((short) 1000, k1, k4);
System.out.println("ScanCursor: "+scanCursor.getKeyValueList());
scanCursor = client.nextCursor(scanCursor);
System.out.println("ScanCursor next: "+scanCursor.getKeyValueList());
client.closeCursor(scanCursor);</code></pre>
            <p>A simple use of cluster cursors:</p>
            <pre><code>ClusterClient.ClusterCursor keyCursor = client.openKeyCursor((short) 1000);
System.out.println("KeyCursor: "+keyCursor.getResult());
keyCursor = client.nextCursor(keyCursor);
System.out.println("KeyCursor: "+keyCursor.getResult());
keyCursor.close();

ClusterClient.ClusterCursor keyValueCursor = client.openKeyValueCursor((short) 40);
System.out.println("KeyValueCursor: "+keyValueCursor.getResult());
keyValueCursor = client.nextCursor(keyValueCursor);
System.out.println("KeyValueCursor: "+keyValueCursor.getResult());
keyValueCursor.close();

ClusterClient.ClusterCursor scanCursor = client.openScanCursor((short) 750, k1, k4);
System.out.println("ScanCursor: "+scanCursor.getResult());
scanCursor = client.nextCursor(scanCursor);
System.out.println("ScanCursor: "+scanCursor.getResult());
scanCursor.close();</code></pre>
            <h4>
<a id="stored-procedures-2" class="anchor" href="#stored-procedures-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4.7. Stored Procedures</h4>
            <p>Stored procedures are able to be defined using stored procedure files, the Invoker Class, and the invoke function. First, Some sort of stored procedure must be defined. In this example we will be using a StoreProc.groovy file (.groovy stored procedures are defaulted to config/script) to define our stored procedure:</p>
            <pre><code>class StoreProc implements StoreMap {
    String city = "irvine"
    ConcurrentMap&lt;String, RemoteStore&gt; storeMaps

    def sayHello(String name) {
        println( "hello new -- $name")
        "hello new -- "+name
    }

    @Override
    void setStoreMap(ConcurrentMap&lt;String, RemoteStore&gt; storeMaps) {
        this.storeMaps = storeMaps
    }
}</code></pre>
            <p>Now that we have our stored procedure defined in a .groovy class file, we need to initialize our Invoker class with this file:</p>
            <pre><code>Invoker invoker = new Invoker("StoreProc.groovy", "sayHello", new Object[] {"test" } );
</code></pre>
            <p>The last step is to actually call, or invoke, this Invoker object:

            </p>
            <pre><code>String result = (String) client.invoke(invoker);
System.out.println(result);</code></pre>
            <p>Using stored procedures in Java is very similar. First, a stored procedure must be created in Java then put into a .jar file. The .jar file must be linked on startup (usually by placing into lib or dist folder).</p>
            <pre><code>public class JavaStoreProc implements StoreMap{
    ConcurrentMap&lt;String, RemoteStore&gt; storeMaps;
    public void helloWorld(String name){
        System.out.println("Hello, " + name);
    }
    @Override
    public void setStoreMap(ConcurrentMap&lt;String, RemoteStore&gt; storeMaps) {
        this.storeMaps = storeMaps;
    }
}</code></pre>
            <p>Creating and calling the invoker is the same except the fully qualified class name must be specified in place of the Groovy script.</p>
            <pre><code>Invoker invoker = new Invoker("com.mycompany.app.JavaStoreProc", "helloWorld", new Object[] {"test" } );
</code></pre>
            <p>The invoker will initialize the class based using the default constructor without arguments. Arguments can be passed to the method being called.

            </p>
            <h3>
<a id="key-sequencing" class="anchor" href="#key-sequencing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.5. Key Sequencing</h3>
            <p>CacheStore supports the use of sequencing data, which is recommended to keep keys organized and avoid key collision problems. To get started with sequencing, first create a store with keys that contain integer data = 0. Whenever accessing this store, use the client function "getSeqNoInt(Key key)". This will automatically increment the data by 1. Other than sequencing, this function can be used for however the developer wants.

            </p>
            <h3>
<a id="serialization" class="anchor" href="#serialization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.6. Serialization</h3>
            <p>CacheStore supports multiple types of serialization for storing and retrieving objects. It is defaulted to use Hessian, but can be implemented with custom serialization.To specify what kind of serialization to use, change the &lt;className&gt; field in the <a href="#stores-xml">stores.xml File</a>. Serialization must occur on both the server and client side so the serializer must be present on both ends.
            </p>
            <h4>
<a id="hessian-serialization" class="anchor" href="#hessian-serialization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.6.1. Hessian Serialization</h4>
            <p>The default Hessian serialization is included in the CacheStore package. More information on Hessian Serialization can be found <a hfref=http://hessian.caucho.com>Here</a>.

            </p>
            <h3>
<a id="mapreduce2" class="anchor" href="#mapreduce2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.7. Map Reduce</h3>
            <p>Exection of the Map Reduce from the client-side is the same as executing a <a href="#stored-procedures-2">Stored Procedure</a>. The only difference is the implementation of the Stored Procedure, in this case by implementing MapReduce in addition to StoreMap.
            </p>
            <p>The following is an implementation of the Map Reduce Stored Procedure, an example model (Value) it uses, and an Invoker call to execute it.</p>
            <pre><code>
public class AggregateMR implements StoreMap, MapReduce&lt;Value&gt; {
    Map&lt;String, RemoteStore&gt; storeMaps;
    Serializer serializer = new HessianSerializer();
    public Value aggregate(String store, int threadCount) {
        ExecMapReduce execMapReduce = new ExecMapReduce(storeMaps, Value.class, this, serializer);
        Value ag = (Value) execMapReduce.execute(store, threadCount);
        return ag;
    }
    @Override
    public void beforeMapStart(Value record, int taskNo, Map&lt;String, Object&gt; context) {
    //Do something before map starts
    }

    @Override
    public void map(Pair&lt;Key, Object&gt; pair, Value record, Map&lt;String, Object&gt; map) {
        record.count();
    }

    @Override
    public void afterMapComplete(Value record, int taskNo, Map&lt;String, Object&gt; context) {
    //Do something after map completes
    }

    @Override
    public Value reduce(List&lt;Value&gt; list) {
        System.out.println("reduce");
        Value total = new Value();
        for(Value each:list){
            total.addCount(each.getCount());
        }
        total.setTotal(total.count);
        return total;
    }
    
    @Override
    public void setStoreMap(ConcurrentMap&lt;String, RemoteStore&gt; storeMaps) {
        this.storeMaps = storeMaps;
    }
}
            </code></pre>
            <p>
            The Map Reduce is executed with execMapReduce. The Map Reduce functions do exactly what they say. beforeMapStart occurs before the map starts, map is the map function, afterMapComplete occurs after the map, and reduce is the reduce function that happens after all the map functions finish.
            </p>
            <pre><code>
public class Value implements Serializable {
    int count ;
    int total ;

    public Value() { }

    public Value(int count, int total) {
        this.count = count;
        this.total = total;
    }

    public void count() {
        count++;
    }
    public  void addCount(int count) {
        this.count += count;
    }

    public int getCount() {
        return count;
    }

    public void setCount(int count) {
        this.count = count;
    }

    public int getTotal() {
        return total;
    }

    public void setTotal(int total) {
        this.total = total;
    }
    

    @Override
    public String toString() {
        return "Value{" +
                "count=" + count +
                ", total=" + total +
                '}';
    }
}
            </code></pre>
            <p>
            The Map Reduce can be implemented however it is needed, but this example shows Value as being a simple aggregate counter.
            </p>
            <pre><code>
Invoker invoker = new Invoker("com.cachestore.example.AggregateMR", "aggregate", new Object[] {"workers", 2} );
Object object = client.invoke(invoker);
            </code></pre>
            <p>
                The Map Reduce is called client-side the same way <a href=#stored-procedures-2>Stored Procedures</a> are. The Map Reduce and model object(s) must be on both the client and server when executing.
            </p>



            <h2>
<a id="config" class="anchor" href="#config" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4. Store and Cluster Config Files</h2>
            <p>The Config files allow users to setup and customize CacheStore servers, clusters, and stores.</p>
            <h3>
<a id="store-config" class="anchor" href="#store-config" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.1. Store Config</h3>
            <p>The stores.xml is used by every instance of CacheStore. Store configuration allows users to setup how they want their data to be stored and accessed.</p>
            <h4>
<a id="stores-xml" class="anchor" href="#stores-xml" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.1.1. The stores.xml File</h4>
            <p>Store metadata is defined in the stores.xml file in the config folder.</p>
            <p>A stores.xml file with all tags filled with their data type:</p>
            <pre><code>&lt;clusters&gt;
  &lt;port&gt;int&lt;/port&gt;
  &lt;className&gt;String&lt;/className&gt;
  &lt;maxQueue&gt;int&lt;/maxQueue&gt;
  &lt;maxThread&gt;int&lt;/maxThread&gt;
  &lt;replicaPort&gt;int&lt;/replicaPort&gt;
  &lt;freq&gt;int&lt;/freq&gt;
  &lt;useNio&gt;boolean&lt;/useNio&gt;
  &lt;store&gt;
    &lt;name&gt;String&lt;/name&gt;
    &lt;path&gt;String&lt;/path&gt;
    &lt;delay&gt;boolean&lt;/delay&gt;
    &lt;mode&gt;int&lt;/mode&gt;
    &lt;freq&gt;int&lt;/freq&gt;
    &lt;batchSize&gt;int&lt;/batchSize&gt;
    &lt;logPath&gt;String&lt;/logPath&gt;
    &lt;replicaUrl&gt;List&lt;/replicaUrl&gt;
    &lt;replicaTimeout&gt;long&lt;/replicaTimeout&gt;
    &lt;sorted&gt;boolean&lt;/sorted&gt;
    &lt;getTrigger&gt;String&lt;/getTrigger&gt;
    &lt;putTrigger&gt;String&lt;/putTrigger&gt;
    &lt;deleteTrigger&gt;String&lt;/deleteTrigger&gt;
    &lt;useMaxCache&gt;boolean&lt;/useMaxCache&gt;
    &lt;maxCacheMemory&gt;int&lt;/maxCacheMemory&gt;
    &lt;useLRU&gt;boolean&lt;/useLRU&gt;
    &lt;pstReplicaUrl&gt;List&lt;/pstReplicaUrl&gt;
  &lt;/store&gt;
&lt;/clusters&gt;</code></pre>
            <p>And the following is a sample stores.xml file:</p>
            <pre><code>&lt;clusters&gt;
  &lt;port&gt;4200&lt;/port&gt;
  &lt;replicaPort&gt;4204&lt;/replicaPort&gt;
  &lt;store&gt;
    &lt;name&gt;test&lt;/name&gt;
    &lt;path&gt;data&lt;/path&gt;
    &lt;delay&gt;false&lt;/delay&gt;
    &lt;mode&gt;0&lt;/mode&gt;
    &lt;freq&gt;10&lt;/freq&gt;
    &lt;batchSize&gt;1&lt;/batchSize&gt;
    &lt;sorted&gt;true&lt;/sorted&gt;
    &lt;getTrigger&gt;com.mycompany.app.GetTrigger&lt;/getTrigger&gt;
    &lt;putTrigger&gt;com.mycompany.app.PutTrigger&lt;/putTrigger&gt;
    &lt;deleteTrigger&gt;com.mycompany.app.DeleteTrigger&lt;/deleteTrigger&gt;
  &lt;/store&gt;
  &lt;store&gt;
    &lt;name&gt;store&lt;/name&gt;
    &lt;path&gt;data&lt;/path&gt;
    &lt;delay&gt;false&lt;/delay&gt;
    &lt;mode&gt;0&lt;/mode&gt;
    &lt;freq&gt;10&lt;/freq&gt;
    &lt;batchSize&gt;1&lt;/batchSize&gt;
    &lt;sorted&gt;true&lt;/sorted&gt;
  &lt;/store&gt;
&lt;/clusters&gt;</code></pre>
            <p>Each tag contains information on store metadata.</p>
            <ul>
                <li class="default"><code>&lt;clusters&gt;</code>: Defines all the stores</li>
                <li class="default"><code>&lt;port&gt;</code>: Defines the port that the store will be opened on</li>
                <li class="default"><code>&lt;className&gt;</code>: Defines which serializer to use</li>
                <li class="default"><code>&lt;maxQueue&gt;</code>: Defines max queue</li>
                <li class="default"><code>&lt;maxThread&gt;</code>: Defines max thread</li>
                <li class="default"><code>&lt;replicaPort&gt;</code>: Defines the port that will be used for replication</li>
                <li class="default"><code>&lt;freq&gt;</code>: Defines the frequency of replication</li>
                <li class="default"><code>&lt;useNio&gt;</code>: Defines whether or not to use NIO, Non-Blocking I/O</li>
                <li class="default"><code>&lt;store&gt;</code>: Defines a store and contains metadata on the defined store</li>
                <li class="default"><code>&lt;name&gt;</code>: Defines the name of the store</li>
                <li class="default"><code>&lt;path&gt;</code>: Defines the path the store, and hence the store's data, will be written to</li>
                <li class="default"><code>&lt;delay&gt;</code>: Defines whether there will be delay</li>
                <li class="default"><code>&lt;mode&gt;</code>: Defines the mode</li>
                <li class="default"><code>&lt;freq&gt;</code>: Defines the frequency of replication</li>
                <li class="default"><code>&lt;batchSize&gt;</code>: Defines the batch size</li>
                <li class="default"><code>&lt;logPath&gt;</code>: Defines the path that logs will be written to</li>
                <li class="default"><code>&lt;replicaUrl&gt;</code>: Defines the replica URL</li>
                <li class="default"><code>&lt;replicaTimeout&gt;</code>: Defines how long it takes for the replica to timeout</li>
                <li class="default"><code>&lt;sorted&gt;</code>: Defines whether to use a sorted/ordered map or an unsorted/unordered map</li>
                <li class="default"><code>&lt;getTrigger&gt;</code>: Defines a GetTrigger using fully qualified class name</li>
                <li class="default"><code>&lt;putTrigger&gt;</code>: Defines a PutTrigger using fully qualified class name</li>
                <li class="default"><code>&lt;deleteTrigger&gt;</code>: Defines a DeleteTrigger using fully qualified class name</li>
                <li class="default"><code>&lt;useMaxCache&gt;</code>: Defines whether or not to use max cache</li>
                <li class="default"><code>&lt;maxCacheMemory&gt;</code>: Defines the max cache memory size</li>
                <li class="default"><code>&lt;useLRU&gt;</code>: Defines whether to use LRU</li>
                <li class="default"><code>&lt;pstReplicaUrl&gt;</code>: Defines pst Replication URL</li>
            </ul>
            <h3>
<a id="cluster-config" class="anchor" href="#cluster-config" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.2. Cluster Config</h3>
            <p>Unlike remotes and local stores, configuration of clusters are handled in three files: clusters.xml, stores.xml, and node.properties. The clusters.xml contains metadata for the cluster as a whole. The stores.xml contains metadata for the stores contained within the cluster. The node.properties contains metadata specifically for the current node. All nodes within the same cluster should share the same clusters.xml and stores.xml, but have unique node.properties. The corresponding config files should be in the same config path, defined when initializing the cluster.</p>
            <h4>
<a id="clusters-xml" class="anchor" href="#clusters-xml" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.2.1. The clusters.xml File</h4>
            <p>Cluster metadata is defined in the clusters.xml file in the config folder. The following is a sample clusters.xml file:</p>
            <pre><code>&lt;clusters&gt;
  &lt;cluster&gt;
      &lt;no&gt;1&lt;/no&gt;
      &lt;servers&gt;ash2-voxd014.sm-us.sm.local:6172, ash2-voxd004.sm-us.sm.local:6182&lt;/servers&gt;
      &lt;partitions&gt;0,1&lt;/partitions&gt;
  &lt;/cluster&gt;
&lt;/clusters&gt;</code></pre>
            <p>Each tag contains information on cluster metadata.</p>
            <ul>
                <li class="default"><code>&lt;clusters&gt;</code>: Defines all the clusters</li>
                <li class="default"><code>&lt;cluster&gt;</code>: Defines a single cluster</li>
                <li class="default"><code>&lt;no&gt;</code>: Defines the number of the cluster</li>
                <li class="default"><code>&lt;servers&gt;</code>: Defines which servers will be contained in the cluster</li>
                <li class="default"><code>&lt;partitions&gt;</code>: Defines how the cluster's data will be partitioned</li>
            </ul>
            <h4>
<a id="stores-xml-2" class="anchor" href="#stores-xml-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.2.2. The stores.xml File</h4>
            <p>Cluster setups also require a stores.xml file on each node. Please refer to <a href=#stores-xml>"Store Config - The stores.xml File"</a> for information regarding stores.xml configuration.</p>
            <h4>
<a id="node-properties" class="anchor" href="#node-properties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.2.3. The node.properties File</h4>
            <p>Node properties are stored within this file. The node.properties file designates which node in the cluster the specific node is. The following is a sample node.properties file:</p>
            <pre><code>host=ash2-voxd004.sm-us.sm.local
port=6182</code></pre>
            <p>Notice how unlike the other two config files, node.properties does not use XML. It is a .properties file that just defines the host and the port number that the current node is using.</p>

            <h2>
<a id="jmx-monitoring" class="anchor" href="#jmx-monitoring" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5. JMX Monitoring</h2>
            <p>CacheStore uses JMX monitoring. To implement and access JMX monitoring for CacheStore, first set up your jmxremote.password and jmxremote.access files.</p>
            <p>Once those are set up, place the following code snippet into your startup script (we recommend using StartCachestore.sh):</p>
            <pre><code>if [ -z $OPTS ]; then
    OPTS="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8999 \
        -Dcom.sun.management.jmxremote.protocol.port=8998 \
        -Dcom.sun.management.jmxremote.ssl=false \
        -Dcom.sun.management.jmxremote.authenticate=true \
        -Dcom.sun.management.jmxremote.password.file=./bin/jmxremote.password \
        -Dcom.sun.management.jmxremote.access.file=./bin/jmxremote.access"
fi</code></pre>
            <p>Once this has been setup, start CacheStore. Then you can open a new terminal and type jconsole to connect.</p>
            <p>More information on JMX monitoring can be <a href=http://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html>Here</a>.</p>
            <h2>
<a id="maven" class="anchor" href="#maven" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6. Maven</h2>
            <p>CacheStore libraries have been uploaded to the Maven Central Repository.</p>
            <p>More information about Maven can be found <a href=https://maven.apache.org>Here</a>.</p>
            <h2>
<a id="maven-dependencies" class="anchor" href="#maven-dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.1 Maven Dependencies</h2>
            <p>CacheStore can be used as a standalone system or used as a plugin. To get CacheStore in your own project, add the following dependency in your pom.xml file:</p>
            <pre><code>    &lt;dependency&gt;
        &lt;groupId>com.viantinc.cachestore&lt;/groupId&gt;
        &lt;artifactId&gt;cachestore&lt;/artifactId&gt;
        &lt;version&gt;1.1.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.viantinc.cachestore&lt;/groupId&gt;
        &lt;artifactId&gt;client&lt;/artifactId&gt;
        &lt;version>1.5.6&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.viantinc.cachestore&lt;/groupId&gt;
        &lt;artifactId&gt;core&lt;/artifactId&gt;
        &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.viantinc.cachestore&lt;/groupId&gt;
        &lt;artifactId&gt;server&lt;/artifactId&gt;
        &lt;version&gt;1.6.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.viantinc.cachestore&lt;/groupId&gt;
        &lt;artifactId&gt;objectquery&lt;/artifactId&gt;
        &lt;version&gt;1.5.8&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.viantinc.cachestore&lt;/groupId&gt;
        &lt;artifactId&gt;replica&lt;/artifactId&gt;
        &lt;version&gt;2.2.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.viantinc.cachestore&lt;/groupId&gt;
        &lt;artifactId&gt;transport&lt;/artifactId&gt;
        &lt;version&gt;2.2.3&lt;/version&gt;
    &lt;/dependency&gt;&gt;</code></pre>
            <p>More information about Maven can be found <a href=https://maven.apache.org>Here</a>.</p>

        </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
        <footer class="inner">
            <p class="copyright">CacheStore is maintained by the <a href="http://viant.github.io/">Viant Data Engineering Team</a></p>
            <p>Feel free to email us at <a href="mailto:dataengineering@viantinc.com">dataengineering@viantinc.com</a></p>
            <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
        </footer>
    </div>



    
</body>

</html>
